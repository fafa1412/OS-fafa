# 第三章：多道程序与分时多任务
## 多道程序放置与加载
在本章中，要一次加载运行多个应用程序，需要每个程序在内存中的起始地址不同。编写脚本 user/build.py 为每个应用定制各自的起始地址， .text 段的地址为 0x80400000 + app_id * 0x20000 。

将负责应用加载和执行的子模块 batch 被拆分为 loader 和 task ， 前者负责启动时加载应用程序，后者负责切换和调度。
其中， loader 模块的 load_apps 函数负责将所有用户程序在内核初始化的时一并加载进内存。
## 任务切换
比如从A任务切换到B任务

A yield

 Trap: __alltraps切换权限级到内核, sepc保存应用程序A下一条指令
 
   Switch:
   
    ra保存A内核switch的返回地址
    
    在内核栈内调换任务, 从B的ra接着执行
    
    连接到__restore, 执行__alltraps里的trap_handler后面接着的代码:__restore
    
 Trap: __restore 从内核栈恢复应用程序环境, 从B的sepc接着执行
 
回到B的用户执行环境执行B

## 多道程序与协作式调度
![image](https://github.com/fafa1412/OS-fafa/assets/145512978/0935d0e9-6da4-4449-b750-3169e0005d69)

利用任务控制块来保存任务运行状态和任务上下文等信息，再用一个全局的任务管理器来管理这些用任务控制块描述的应用。

sys_yield 和 sys_exit 系统调用利用 suspend_current_and_run_next 和 exit_current_and_run_next接口实现，它们都是先修改当前应用的运行状态，然后尝试切换到下一个应用。

修改运行状态简单，调用任务管理器方法中的可变变量修改状态

切换下一个应用，run_next_task 使用任务管理器的全局实例 TASK_MANAGER 的 run_next_task 方法。它会调用 find_next_task 方法尝试寻找一个运行状态为 Ready 的应用并返回其 ID 。如果能够找到下一个可运行的应用的话，我们就可以分别拿到当前应用 current_task_cx_ptr 和即将被切换到的应用 next_task_cx_ptr 的任务上下文指针，然后调用 __switch 接口进行切换。如果找不到的话，说明所有的应用都运行完毕了，我们可以直接 panic 退出内核。

# 编程作业
* 在系统调用模块中，添加一个新的系统调用处理函数sys_task_info，并将其与系统调用号410关联。（代码仓库已给出）

* 我在sys_task_info函数中，获取当前任务的引用，即正在运行的任务。使用get_current_task()函数，但是由于语法知识缺失，这个函数总是有错误，把rust学完再来写

* 创建一个TaskInfo结构体对象（已给出），并使用当前任务的状态、系统调用次数和运行时间填充该结构体。

* 将填充后的TaskInfo对象复制到用户空间提供的指针ti所指向的内存位置。这可以使用unsafe代码块来完成。

* 返回0表示执行成功，或者返回-1表示错误。
大体的框架觉得没问题，但是关于细节上，如何每系统调用一次，syscall_times数组相应变化，根据提示，*系统调用次数可以考虑在进入内核态系统调用异常处理函数之后，进入具体系统调用函数之前维护。*，找到syscall系统调用函数就好，思路理清了，但是代码实现总是有问题，还是要跟着rust的学习来。
* 至于任务运行状态较简单，调用时一定是running
* 任务运行时间来说，，在任务初始化时利用get_time()调用，获得一个开始时间start_time,接着当调用到sys_task_info是，获得一个当前时间，相减。

**一定记得不同文件之间函数和包的引入**
接下来不仅是理解掌握，更要配合rust语言写出来
